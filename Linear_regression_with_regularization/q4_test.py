# -*- coding: utf-8 -*-
"""Q4_test.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dUjXq9nEOX2PMOboEnFAB_-x-hQGM49x
"""

import numpy as np
import matplotlib.pyplot as plt
from preprocessing.polynomial_features import PolynomialFeatures
from linearRegression.linear_regression import LinearRegression
import pandas as pd
import os.path
from os import path
from metrics import *
from sklearn.preprocessing import StandardScaler
np.random.seed(45)  #Setting seed for reproducibility

if not path.exists('Plots/Question4_test/'):
  os.makedirs('Plots/Question4_test/')



#TODO : Write here
#Preprocess the input using the polynomial features
#Solve the resulting linear regression problem by calling any one of the 
#algorithms you have implemented.

x = np.array([i*np.pi/180 for i in range(60,500,2)])
y = 3*x + 8 + np.random.normal(0,3,len(x))
x=x.reshape(x.shape[0],1)

#Plot the data
plt.scatter(x,y)
plt.xlabel('x')
plt.ylabel('y')
plt.title('Data')
plt.savefig('Plots/Question4/Data.png')
plt.show()

# for bs in [1, 8, 16,32,64,128]:
for bs in [32]:
  print("############ Batch Size : {} ############".format(bs))
  degrees=range(4,41)
  norms=[]
  for degree in degrees:
    P_Features = PolynomialFeatures(degree)
    X_poly = P_Features.transform(x)
    scaler = StandardScaler()
    X_poly_scaled = scaler.fit_transform(X_poly)
    # X_poly_scaled = X_poly
    model = LinearRegression()
    model.fit_gradient_descent(X_poly_scaled,y,gradient_type='manual',penalty_type='l2', alpha=0.05, batch_size=bs, num_iters=10,lr=0.01, print_data = False)
    norms.append(np.linalg.norm(model.coef_))

    y_hat = model.predict(X_poly_scaled)
    print('Degree : {} rmse : {} mae : {}'.format(degree,round(rmse(y_hat,y),3),round(mae(y_hat,y),3)))

  plt.plot(degrees,norms)
  plt.xlabel('Degree')
  plt.ylabel('Norm')
  plt.title('Norm vs Degree')
  plt.savefig(f'Plots/Question4_test/Norm_vs_Degree_batchsize={bs}.png') 
  plt.show()
